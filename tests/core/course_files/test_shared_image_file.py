"""Tests for SharedImageFile - image files copied to shared img/ folder."""

from pathlib import Path
from unittest.mock import AsyncMock, MagicMock

import pytest

from clm.core.course_files.shared_image_file import SharedImageFile
from clm.core.utils.execution_utils import (
    COPY_GENERATED_IMAGES_STAGE,
    FIRST_EXECUTION_STAGE,
)
from clm.infrastructure.operation import Concurrently, NoOperation


class TestSharedImageFile:
    """Tests for the SharedImageFile class."""

    @pytest.fixture
    def mock_course(self):
        """Create a mock course object."""
        course = MagicMock()
        course.output_root = Path("/output")
        course.output_languages = None  # Default to both languages
        course.output_kinds = None  # Default to all kinds
        course.name = {"de": "Mein-Kurs", "en": "My-Course"}
        return course

    @pytest.fixture
    def mock_topic(self):
        """Create a mock topic object."""
        topic = MagicMock()
        topic.path = Path("/course/slides/module_01/topic_test")
        return topic

    @pytest.fixture
    def image_file(self, mock_course, mock_topic, tmp_path):
        """Create a SharedImageFile for testing with an existing source file."""
        img_path = tmp_path / "test_image.png"
        img_path.write_bytes(b"PNG data")
        # Use _from_path to properly detect source existence
        return SharedImageFile._from_path(mock_course, img_path, mock_topic)

    @pytest.fixture
    def generated_image_file(self, mock_course, mock_topic, tmp_path):
        """Create a SharedImageFile for a non-existing (generated) image."""
        # Path to an image that doesn't exist yet (e.g., will be generated by DrawIO)
        img_path = tmp_path / "generated_image.png"
        # Don't create the file - simulate a generated image
        return SharedImageFile._from_path(mock_course, img_path, mock_topic)

    def test_execution_stage_is_first_for_existing_images(self, image_file):
        """Test that existing images run in the first execution stage."""
        assert image_file.execution_stage == FIRST_EXECUTION_STAGE

    def test_execution_stage_is_later_for_generated_images(self, generated_image_file):
        """Test that generated images run in COPY_GENERATED_IMAGES_STAGE.

        Generated images (from DrawIO/PlantUML) don't exist at load time,
        so they need to run after the conversion stage completes.
        """
        assert generated_image_file.execution_stage == COPY_GENERATED_IMAGES_STAGE

    @pytest.mark.asyncio
    async def test_get_processing_operation_returns_noop_for_wrong_stage(self, image_file):
        """Test that wrong stage returns NoOperation for existing images."""
        # Existing images run in FIRST_EXECUTION_STAGE, so other stages return NoOp
        op = await image_file.get_processing_operation(
            Path("/output"), stage=COPY_GENERATED_IMAGES_STAGE
        )
        assert isinstance(op, NoOperation)

    @pytest.mark.asyncio
    async def test_generated_image_returns_noop_for_first_stage(self, generated_image_file):
        """Test that generated images return NoOperation for FIRST_EXECUTION_STAGE."""
        # Generated images run in COPY_GENERATED_IMAGES_STAGE, not first stage
        op = await generated_image_file.get_processing_operation(
            Path("/output"), stage=FIRST_EXECUTION_STAGE
        )
        assert isinstance(op, NoOperation)

    @pytest.mark.asyncio
    async def test_get_processing_operation_returns_concurrently(self, image_file):
        """Test that correct stage returns Concurrently with copy operations."""
        op = await image_file.get_processing_operation(Path("/output"), stage=FIRST_EXECUTION_STAGE)
        assert isinstance(op, Concurrently)

    @pytest.mark.asyncio
    async def test_generated_image_returns_concurrently_at_correct_stage(
        self, generated_image_file
    ):
        """Test that generated images return Concurrently at COPY_GENERATED_IMAGES_STAGE."""
        op = await generated_image_file.get_processing_operation(
            Path("/output"), stage=COPY_GENERATED_IMAGES_STAGE
        )
        assert isinstance(op, Concurrently)

    @pytest.mark.asyncio
    async def test_copies_to_both_languages_both_audiences(self, image_file, mock_course):
        """Test that images are copied for de/en and public/speaker."""
        mock_course.output_languages = None  # Both languages
        mock_course.output_kinds = None  # Both public and speaker

        op = await image_file.get_processing_operation(Path("/output"), stage=FIRST_EXECUTION_STAGE)

        # Should have 4 operations: de-public, de-speaker, en-public, en-speaker
        assert isinstance(op, Concurrently)
        assert len(op.operations) == 4

    @pytest.mark.asyncio
    async def test_copies_to_single_language(self, image_file, mock_course):
        """Test that images are copied for only specified language."""
        mock_course.output_languages = ["de"]
        mock_course.output_kinds = None  # Both public and speaker

        op = await image_file.get_processing_operation(Path("/output"), stage=FIRST_EXECUTION_STAGE)

        # Should have 2 operations: de-public, de-speaker
        assert isinstance(op, Concurrently)
        assert len(op.operations) == 2

    @pytest.mark.asyncio
    async def test_speaker_only_copies_to_speaker(self, image_file, mock_course):
        """Test that speaker-only mode copies only to speaker directories."""
        mock_course.output_languages = None  # Both languages
        mock_course.output_kinds = ["speaker"]

        op = await image_file.get_processing_operation(Path("/output"), stage=FIRST_EXECUTION_STAGE)

        # Should have 2 operations: de-speaker, en-speaker
        assert isinstance(op, Concurrently)
        assert len(op.operations) == 2

    @pytest.mark.asyncio
    async def test_output_path_includes_img_folder(self, image_file, mock_course):
        """Test that output path includes img/ subfolder."""
        from clm.core.operations.copy_file import CopyFileOperation

        op = await image_file.get_processing_operation(Path("/output"), stage=FIRST_EXECUTION_STAGE)

        # Check one of the operations has correct path structure
        assert isinstance(op, Concurrently)
        copy_op = op.operations[0]
        assert isinstance(copy_op, CopyFileOperation)
        assert "img" in copy_op.output_file.parts
        assert copy_op.output_file.name == "test_image.png"

    @pytest.mark.asyncio
    async def test_output_path_preserves_subfolder_structure(
        self, mock_course, mock_topic, tmp_path
    ):
        """Test that images in subfolders preserve their subfolder structure in output."""
        from clm.core.operations.copy_file import CopyFileOperation

        # Create an image in a subfolder of img/
        img_dir = tmp_path / "img" / "charts"
        img_dir.mkdir(parents=True)
        img_path = img_dir / "diagram.png"
        img_path.write_bytes(b"PNG data")

        image_file = SharedImageFile._from_path(mock_course, img_path, mock_topic)

        op = await image_file.get_processing_operation(Path("/output"), stage=FIRST_EXECUTION_STAGE)

        # Check that the output path preserves the subfolder structure
        assert isinstance(op, Concurrently)
        copy_op = op.operations[0]
        assert isinstance(copy_op, CopyFileOperation)
        # Output should be .../img/charts/diagram.png
        assert "img" in copy_op.output_file.parts
        assert "charts" in copy_op.output_file.parts
        assert copy_op.output_file.name == "diagram.png"
        # Verify the order: img should come before charts
        parts = copy_op.output_file.parts
        img_idx = parts.index("img")
        charts_idx = parts.index("charts")
        assert img_idx < charts_idx

    @pytest.mark.asyncio
    async def test_output_path_preserves_deeply_nested_subfolder(
        self, mock_course, mock_topic, tmp_path
    ):
        """Test that deeply nested subfolders are preserved."""
        from clm.core.operations.copy_file import CopyFileOperation

        # Create an image in a deeply nested subfolder
        img_dir = tmp_path / "img" / "a" / "b" / "c"
        img_dir.mkdir(parents=True)
        img_path = img_dir / "deep.png"
        img_path.write_bytes(b"PNG data")

        image_file = SharedImageFile._from_path(mock_course, img_path, mock_topic)

        op = await image_file.get_processing_operation(Path("/output"), stage=FIRST_EXECUTION_STAGE)

        # Check that the full subfolder structure is preserved
        assert isinstance(op, Concurrently)
        copy_op = op.operations[0]
        assert isinstance(copy_op, CopyFileOperation)
        output_str = str(copy_op.output_file)
        # Should contain img/a/b/c/deep.png
        assert "img" in output_str
        assert output_str.endswith("deep.png")
        # Verify full path structure
        parts = copy_op.output_file.parts
        assert "a" in parts
        assert "b" in parts
        assert "c" in parts


class TestSharedImageFileClassification:
    """Tests for SharedImageFile being selected by _find_file_class in shared mode."""

    def test_image_files_use_shared_image_file_in_shared_mode(self, tmp_path):
        """Test that image files are classified as SharedImageFile in shared mode."""
        from clm.core.course_file import _find_file_class
        from clm.core.course_files.shared_image_file import SharedImageFile

        for ext in [".png", ".jpg", ".jpeg", ".gif", ".svg"]:
            img_path = tmp_path / f"test{ext}"
            img_path.write_bytes(b"image data")
            # Must explicitly use shared mode since default is now duplicated
            assert _find_file_class(img_path, image_mode="shared") is SharedImageFile

    def test_non_image_files_use_data_file(self, tmp_path):
        """Test that non-image files are classified as DataFile."""
        from clm.core.course_file import _find_file_class
        from clm.core.course_files.data_file import DataFile

        for ext in [".txt", ".csv", ".json", ".xml"]:
            file_path = tmp_path / f"test{ext}"
            file_path.write_text("data")
            # Non-image files are DataFile regardless of mode
            assert _find_file_class(file_path, image_mode="shared") is DataFile

    def test_imgdata_folder_files_not_shared_image(self, tmp_path):
        """Test that files in imgdata folders are not SharedImageFile."""
        from clm.core.course_file import _find_file_class
        from clm.core.course_files.data_file import DataFile

        imgdata_dir = tmp_path / "imgdata"
        imgdata_dir.mkdir()
        img_path = imgdata_dir / "test.png"
        img_path.write_bytes(b"image data")

        # Files in imgdata folder should be DataFile, not SharedImageFile
        assert _find_file_class(img_path, image_mode="shared") is DataFile
